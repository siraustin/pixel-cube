<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixelated Vision Cube Simulator</title>
    <link rel="stylesheet" href="https://cdn.replit.com/agent/bootstrap-agent-dark-theme.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <style>
        .logo {
            width: 100px;
            height: auto;
        }

        #canvas {
            background-color: var(--bs-dark);
            border-radius: 8px;
            max-height: 70vh;
        }

        .controls {
            background-color: var(--bs-dark);
            padding: 1rem;
            border-radius: 8px;
        }

        .form-range::-webkit-slider-thumb {
            background: var(--bs-primary);
        }

        .form-range::-moz-range-thumb {
            background: var(--bs-primary);
        }
    </style>
</head>
<body>
    <div class="container py-4">
        <div class="row justify-content-center">
            <div class="col-12 text-center mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100" class="logo mb-3">
                    <style>
                        .cube { fill: #007bff; }
                        .pixels { fill: #ffffff; opacity: 0.3; }
                    </style>
                    <rect class="cube" x="20" y="20" width="60" height="60" rx="5"/>
                    <g class="pixels">
                        <rect x="30" y="30" width="10" height="10"/>
                        <rect x="45" y="30" width="10" height="10"/>
                        <rect x="60" y="30" width="10" height="10"/>
                        <rect x="30" y="45" width="10" height="10"/>
                        <rect x="45" y="45" width="10" height="10"/>
                        <rect x="60" y="45" width="10" height="10"/>
                        <rect x="30" y="60" width="10" height="10"/>
                        <rect x="45" y="60" width="10" height="10"/>
                        <rect x="60" y="60" width="10" height="10"/>
                    </g>
                </svg>
                <h1 class="display-5">Pixelated Vision Cube Simulator</h1>
            </div>

            <div class="col-12 col-md-10 col-lg-8">
                <div class="card bg-dark">
                    <div class="card-body">
                        <!-- Initial permission request UI -->
                        <div id="startPrompt" class="text-center py-4">
                            <p class="mb-3">This simulator needs access to your camera to demonstrate the pixelation effect.</p>
                            <button id="startButton" class="btn btn-primary">Turn Camera On</button>
                        </div>

                        <video id="video" style="display: none;" autoplay playsinline crossorigin="anonymous"></video>
                        <canvas id="canvas" class="w-100"></canvas>

                        <div id="controls" class="controls mt-4" style="display: none;">
                            <div class="row align-items-center">
                                <div class="col-12 mb-3">
                                    <div class="d-flex justify-content-between">
                                        <button id="switchCamera" class="btn btn-secondary">
                                            Turn Camera On
                                        </button>
                                        <button id="takeSnapshot" class="btn btn-primary">
                                            Take Snapshot
                                        </button>
                                        <button id="recordVideo" class="btn btn-danger">
                                            Capture Video 
                                        </button>
                                    </div>
                                </div>
                                <div class="col-12">
                                    <label for="pixelation" class="form-label">
                                        Pixelation Level: <span id="pixelValue">16</span>
                                    </label>
                                    <input type="range" 
                                           class="form-range" 
                                           id="pixelation" 
                                           min="5" 
                                           max="50" 
                                           value="16">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="errorMessage" class="alert alert-danger mt-3" style="display: none;">
                    Unable to access camera. Please ensure you have granted camera permissions.
                </div>

                <div class="card bg-dark mt-3" id="snapshotsContainer">
                    <div class="card-header">
                        <h5 class="mb-0">Snapshots & Videos</h5>
                    </div>
                    <div class="card-body">
                        <div id="snapshots" class="row g-3">
                            <!-- Snapshots will be added here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Debug logs -->
    <div class="container mt-4">
        <div class="card bg-dark">
            <div class="card-header d-flex justify-content-between align-items-center">
                <div>
                    <h6 class="mb-0">Debug Logs</h6>
                    <small class="text-muted" id="versionInfo">v0.2a</small>
                </div>
                <div>
                    <!-- <button id="testLogBtn" class="btn btn-sm btn-primary me-2">Test Log</button> -->
                    <button id="clearLogs" class="btn btn-sm btn-secondary">Clear</button>
                </div>
            </div>
            <div class="card-body">
                <div id="debugLogs" class="text-light" style="max-height: 200px; overflow-y: auto; font-size: 12px; white-space: pre-wrap;"></div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Simplified debug logging
            const debugLogs = document.getElementById('debugLogs');
            const clearLogsBtn = document.getElementById('clearLogs');
            
            function debugLog(message, isError = false) {
                const timestamp = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.className = isError ? 'text-danger' : 'text-info';
                entry.textContent = `[${timestamp}] ${message}`;
                
                // Make sure the debugLogs element exists
                if (debugLogs) {
                    debugLogs.appendChild(entry);
                    debugLogs.scrollTop = debugLogs.scrollHeight;
                    
                    // Make sure the parent card is visible
                    const debugCard = debugLogs.closest('.card');
                    if (debugCard) {
                        debugCard.style.display = 'block';
                    }
                }
                
                // Always log to console as backup
                if (isError) {
                    console.error(message);
                } else {
                    console.log(message);
                }
            }
            
            // Test logger button
            // testLogBtn.addEventListener('click', () => {
            //     debugLog("Logger test successful!");
            //     debugLog("If you see this message, logging is working properly.");
            //     alert("Test log message added. Check the Debug Logs section below.");
            // });
            
            // Clear logs button
            clearLogsBtn.addEventListener('click', () => {
                debugLogs.innerHTML = '';
                debugLog('Logs cleared');
            });
            
            // Initial log entry
            debugLog('Debug panel initialized');
            
            // Draw initial canvas message
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 640;
            canvas.height = 640;
            ctx.fillStyle = "#444";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#f00";
            ctx.font = "24px Arial";
            ctx.fillText("Click 'Turn Camera On' to start", 180, canvas.height/2);
            
            const video = document.getElementById('video');
            const pixelationSlider = document.getElementById('pixelation');
            const pixelValue = document.getElementById('pixelValue');
            const errorMessage = document.getElementById('errorMessage');
            const startButton = document.getElementById('startButton');
            const controls = document.getElementById('controls');
            const startPrompt = document.getElementById('startPrompt');
            const switchCameraButton = document.getElementById('switchCamera');

            const takeSnapshotButton = document.getElementById('takeSnapshot');
            const recordVideoButton = document.getElementById('recordVideo');
            const snapshotsContainer = document.getElementById('snapshotsContainer');
            const snapshotsDiv = document.getElementById('snapshots');
            
            let isRecording = false;
            let recordingFrames = [];
            
            let currentStream = null;
            let currentFacingMode = 'user'; // Start with front camera
            let snapshotCount = 0;

            // Set initial canvas size to 1:1 aspect ratio
            canvas.width = 640;
            canvas.height = 640;

            // Update pixelation value display
            pixelationSlider.addEventListener('input', (e) => {
                pixelValue.textContent = e.target.value;
            });

            // Add a function to handle camera mirroring based on which camera is active
            function updateCameraMirroring() {
                // Apply mirror effect for front camera only
                if (currentFacingMode === 'user') {
                    canvas.style.transform = 'scaleX(-1)'; // Mirror horizontally
                } else {
                    canvas.style.transform = 'scaleX(1)'; // Normal display
                }
                debugLog(`Camera mirroring ${currentFacingMode === 'user' ? 'enabled' : 'disabled'} for ${currentFacingMode} camera`);
            }

            // Update the switchCamera function to handle mirroring
            async function switchCamera() {
                if (currentStream) {
                    // If we already have a stream, switch cameras
                    currentStream.getTracks().forEach(track => track.stop());
                    
                    // Toggle facing mode
                    currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
                    
                    try {
                        await initWebcam();
                        // Update button text to indicate current camera
                        switchCameraButton.textContent = `Switch to ${currentFacingMode === 'user' ? 'Back' : 'Front'} Camera`;
                        
                        // Update mirroring based on current camera
                        updateCameraMirroring();
                    } catch (err) {
                        console.error('Failed to switch camera:', err);
                        errorMessage.textContent = 'Failed to switch camera. Please try again.';
                        errorMessage.style.display = 'block';
                    }
                } else {
                    // First time: just turn the camera on
                    try {
                        await initWebcam();
                        // Update button text to indicate switch option now
                        switchCameraButton.textContent = `Switch to Back Camera`;
                        
                        // Set initial mirroring
                        updateCameraMirroring();
                    } catch (err) {
                        console.error('Failed to initialize camera:', err);
                        errorMessage.textContent = 'Failed to turn on camera. Please ensure you have granted camera permissions.';
                        errorMessage.style.display = 'block';
                    }
                }
            }

            // Initialize webcam with better error handling
            async function initWebcam() {
                try {
                    // First check if getUserMedia is supported
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('WebRTC API not supported in this browser');
                    }

                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            facingMode: currentFacingMode,
                            width: { ideal: 640 },
                            height: { ideal: 640 }, // Request square aspect ratio
                            aspectRatio: { ideal: 1 } // Force 1:1 aspect ratio
                        } 
                    });

                    currentStream = stream;
                    video.srcObject = stream;

                    // Always show the switch camera button, we're using it as our main control
                    switchCameraButton.style.display = 'block';

                    // Explicitly start playing the video
                    try {
                        await video.play();
                        console.log('Video playback started successfully');
                        
                        // Draw a message to indicate success
                        ctx.fillStyle = "#007700";
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = "#fff";
                        ctx.font = "24px Arial";
                        ctx.fillText("Camera started successfully!", 160, canvas.height/2);
                        
                        // Show the controls
                        controls.style.display = 'block';
                        startPrompt.style.display = 'none';
                        errorMessage.style.display = 'none';
                        
                        // Force a frame update
                        setTimeout(() => {
                            console.log("Forcing pixelation update");
                            if (video.readyState >= 2) {
                                console.log("Video is ready with state: " + video.readyState);
                                pixelate(canvas, parseInt(pixelationSlider.value));
                            }
                        }, 500);
                    } catch (playError) {
                        console.error('Error playing video:', playError);
                        throw new Error(`Failed to play video: ${playError.message}`);
                    }

                    // Start the animation loop once video is ready
                    video.addEventListener('loadedmetadata', () => {
                        console.log('Video metadata loaded:', {
                            width: video.videoWidth,
                            height: video.videoHeight
                        });
                        // Set canvas size to match video
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        animate();
                    });

                    // Handle video errors
                    video.addEventListener('error', (e) => {
                        console.error('Video element error:', {
                            error: e.error,
                            currentTime: video.currentTime,
                            readyState: video.readyState
                        });
                        errorMessage.textContent = 'Error playing video stream. Please refresh and try again.';
                        errorMessage.style.display = 'block';
                    });

                } catch (err) {
                    console.error('Webcam access error:', {
                        name: err.name,
                        message: err.message,
                        stack: err.stack
                    });

                    let errorMsg = 'Unable to access camera. ';

                    if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                        errorMsg += 'Please ensure you have granted camera permissions and refresh the page.';
                    } else if (err.name === 'NotFoundError') {
                        errorMsg += 'No camera device found. Please connect a camera and refresh.';
                    } else if (err.name === 'NotReadableError') {
                        errorMsg += 'Camera is already in use by another application. Please close other apps using the camera.';
                    } else if (err.name === 'SecurityError') {
                        errorMsg += 'Camera access is blocked. Please ensure you are using HTTPS or localhost.';
                    } else {
                        errorMsg += `An unexpected error occurred: ${err.message}`;
                    }

                    errorMessage.textContent = errorMsg;
                    errorMessage.style.display = 'block';
                }
            }

            // Pixelate the video frame with guaranteed square pixels for all devices
            function pixelate(sourceCanvas, pixelSize) {
                const w = sourceCanvas.width;
                const h = sourceCanvas.height;
                
                // Create a temporary canvas for the pixelation effect
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = w;
                tempCanvas.height = h;
                
                // Draw the video frame
                if (video.readyState >= 2) { // HAVE_CURRENT_DATA or better
                    tempCtx.drawImage(video, 0, 0, w, h);
                } else {
                    console.log("Video not ready yet: " + video.readyState);
                    // Draw a message if video isn't ready
                    ctx.fillStyle = "#444";
                    ctx.fillRect(0, 0, w, h);
                    ctx.fillStyle = "#f00";
                    ctx.font = "24px Arial";
                    ctx.fillText("Waiting for camera...", 180, h/2);
                    return; // Skip the rest of the pixelation
                }
                
                // Determine the size of each square pixel based on the pixelation level
                // This will be a fixed number of pixels on both dimensions
                const totalPixels = Math.max(Math.floor(Math.min(w, h) / pixelSize), 1);
                
                // Calculate final size in pixels for each square
                const pixelWidth = Math.floor(w / totalPixels);
                const pixelHeight = Math.floor(h / totalPixels);
                
                // Calculate centering offsets if there's excess space
                const xOffset = Math.floor((w - (pixelWidth * totalPixels)) / 2);
                const yOffset = Math.floor((h - (pixelHeight * totalPixels)) / 2);
                
                // Clear the canvas
                ctx.clearRect(0, 0, w, h);
                
                // Fill with black background (for any unused space)
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, w, h);
                
                // Disable image smoothing
                ctx.imageSmoothingEnabled = false;
                
                // Debug indication
                ctx.fillStyle = "#444";
                ctx.fillRect(0, 0, w, h);
                ctx.fillStyle = "#f00";
                ctx.font = "20px Arial";
                ctx.fillText("Waiting for camera...", 20, h/2);
                
                // Create square pixels
                for (let y = 0; y < totalPixels; y++) {
                    for (let x = 0; x < totalPixels; x++) {
                        // Calculate the position to sample from the source
                        const sourceX = Math.floor(x * (w / totalPixels) + (w / totalPixels / 2));
                        const sourceY = Math.floor(y * (h / totalPixels) + (h / totalPixels / 2));
                        
                        // Sample the color
                        const data = tempCtx.getImageData(sourceX, sourceY, 1, 1).data;
                        
                        // Draw a square pixel
                        // Force the width and height to be the same to ensure square pixels
                        const size = Math.min(pixelWidth, pixelHeight);
                        
                        ctx.fillStyle = `rgba(${data[0]}, ${data[1]}, ${data[2]}, ${data[3]/255})`;
                        
                        // Position the square with proper centering
                        const pixelX = x * size + xOffset;
                        const pixelY = y * size + yOffset;
                        
                        ctx.fillRect(pixelX, pixelY, size, size);
                    }
                }
                
                // Re-enable image smoothing
                ctx.imageSmoothingEnabled = true;
            }

            // Animation loop
            function animate() {
                if (video.readyState === video.HAVE_ENOUGH_DATA) {
                    // Get current pixelation level
                    const pixelSize = parseInt(pixelationSlider.value);

                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Apply pixelation effect
                    pixelate(canvas, pixelSize);
                }

                // Request next frame
                requestAnimationFrame(animate);
            }

            // Handle window resize
            function handleResize() {
                const container = canvas.parentElement;
                const aspectRatio = canvas.width / canvas.height;
                const newWidth = container.clientWidth;
                const newHeight = newWidth / aspectRatio;

                canvas.style.width = `${newWidth}px`;
                canvas.style.height = `${newHeight}px`;
            }

            // Take snapshot function
            function takeSnapshot() {
                if (video.readyState === video.HAVE_ENOUGH_DATA) {
                    // Create a new snapshot canvas
                    const snapshotCanvas = document.createElement('canvas');
                    snapshotCanvas.width = canvas.width;
                    snapshotCanvas.height = canvas.height;
                    const snapshotCtx = snapshotCanvas.getContext('2d');
                    
                    // Copy the current canvas content to the snapshot canvas
                    snapshotCtx.drawImage(canvas, 0, 0);
                    
                    // Convert to image data URL
                    const imageDataUrl = snapshotCanvas.toDataURL('image/png');
                    
                    // Create snapshot element
                    const snapshotEl = document.createElement('div');
                    snapshotEl.className = 'col-6 col-md-4 col-lg-3';
                    snapshotCount++;
                    
                    // Create snapshot card
                    snapshotEl.innerHTML = `
                        <div class="card">
                            <img src="${imageDataUrl}" class="card-img-top" alt="Snapshot ${snapshotCount}">
                            <div class="card-footer text-center">
                                <a href="${imageDataUrl}" download="pixel-cube-snapshot-${snapshotCount}.png" class="btn btn-sm btn-outline-primary">Download</a>
                                <small class="text-muted ms-2">Snapshot ${snapshotCount}</small>
                            </div>
                        </div>
                    `;
                    
                    // Add to snapshots container
                    snapshotsDiv.prepend(snapshotEl);
                    
                    // Show snapshots container if it's the first snapshot
                    if (snapshotCount === 1) {
                        snapshotsContainer.style.display = 'block';
                    }
                }
            }
            
            // Update the startRecording function to show time in tenths of a second
            function startRecording() {
                if (isRecording) return;
                if (video.readyState !== video.HAVE_ENOUGH_DATA) {
                    debugLog("Cannot record, video not ready", true);
                    return;
                }
                
                debugLog("Starting video recording...");
                isRecording = true;
                recordingFrames = [];
                recordVideoButton.textContent = "0.0s of 7.0s"; // Initialize with 0.0 seconds
                recordVideoButton.disabled = true;
                
                // Record for 7 seconds (at 5 frames per second = 35 frames)
                let framesLeft = 35;
                let totalFrames = framesLeft;
                let elapsedTime = 0; // Track elapsed time in tenths of seconds
                
                debugLog(`Recording ${framesLeft} frames (7 seconds) at ${canvas.width}x${canvas.height}`);
                
                // Timer to update elapsed time display
                const timerInterval = setInterval(() => {
                    elapsedTime += 0.1; // Add one tenth of a second
                    // Format to show one decimal place
                    const timeDisplay = elapsedTime.toFixed(1);
                    recordVideoButton.textContent = `${timeDisplay}s of 7.0s`;
                }, 100); // Update every 100ms (1/10 second)
                
                // Capture a frame with secure method
                function captureFrame() {
                    if (framesLeft <= 0 || !isRecording) {
                        clearInterval(timerInterval); // Stop the timer when done
                        debugLog(`Captured all ${totalFrames} frames`);
                        finishRecording();
                        return;
                    }
                    
                    try {
                        // Create a new frame canvas
                        const frameCanvas = document.createElement('canvas');
                        frameCanvas.width = canvas.width;
                        frameCanvas.height = canvas.height;
                        const frameCtx = frameCanvas.getContext('2d');
                        
                        // IMPORTANT: Draw a solid color first to avoid security issues
                        frameCtx.fillStyle = "#000000";
                        frameCtx.fillRect(0, 0, frameCanvas.width, frameCanvas.height);
                        
                        if (currentFacingMode === 'user') {
                            frameCtx.translate(frameCanvas.width, 0);
                            frameCtx.scale(-1, 1);
                        }
                        
                        // Copy the current canvas content to the frame
                        frameCtx.drawImage(canvas, 0, 0);
                        
                        // Store the frame
                        recordingFrames.push(frameCanvas);
                        debugLog(`Captured frame ${totalFrames-framesLeft+1}/${totalFrames}`);
                    } catch (e) {
                        debugLog(`Error capturing frame: ${e.message}`, true);
                    }
                    
                    // Update button to show progress (we're now using the timer instead)
                    framesLeft--;
                    
                    // Capture the next frame in 200ms (5fps)
                    setTimeout(captureFrame, 200);
                }
                
                // Start capturing frames
                captureFrame();
            }
            
            // Update the finishRecording function with the fixes and make sure all variables are properly initialized
            function finishRecording() {
                if (!isRecording) return;
                
                // Set button to processing state
                recordVideoButton.textContent = "Processing...";
                recordVideoButton.disabled = true;
                
                debugLog("Processing captured frames: " + recordingFrames.length);
                
                try {
                    // First create the static grid view (as a fallback and thumbnail)
                    debugLog("Creating static image grid");
                    
                    // Create a canvas for the static image
                    const gridCanvas = document.createElement('canvas');
                    gridCanvas.width = 640;
                    gridCanvas.height = 480;
                    const ctx = gridCanvas.getContext('2d');
                    
                    // Fill with black background
                    ctx.fillStyle = "#000";
                    ctx.fillRect(0, 0, gridCanvas.width, gridCanvas.height);
                    
                    // Calculate grid layout
                    const gridSize = Math.ceil(Math.sqrt(recordingFrames.length));
                    const cellWidth = Math.floor(gridCanvas.width / gridSize);
                    const cellHeight = Math.floor(gridCanvas.height / gridSize);
                    
                    // Draw frames in a grid
                    recordingFrames.forEach((frame, i) => {
                        try {
                            const row = Math.floor(i / gridSize);
                            const col = i % gridSize;
                            const x = col * cellWidth;
                            const y = row * cellHeight;
                            
                            // Draw the frame
                            ctx.drawImage(frame, 0, 0, frame.width, frame.height, x, y, cellWidth, cellHeight);
                            
                            // Draw frame number
                            ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
                            ctx.font = "14px Arial";
                            ctx.fillText((i+1).toString(), x + 5, y + 20);
                            
                            // Update progress
                            recordVideoButton.textContent = `Processing ${Math.round((i+1) / recordingFrames.length * 100)}%`;
                        } catch (frameErr) {
                            debugLog(`Error drawing frame ${i}: ${frameErr.message}`, true);
                        }
                    });
                    
                    // Get static grid as data URL
                    const staticImageUrl = gridCanvas.toDataURL('image/png');
                    debugLog("Created static image grid");
                    
                    // Prepare frames for Web Animation API
                    debugLog("Creating web animation from frames");
                    
                    // Create individual frame images as data URLs
                    const frameDataUrls = [];
                    const frameSize = 320; // Animation size
                    
                    // Create a temporary canvas for frame resizing
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = frameSize;
                    tempCanvas.height = frameSize;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Convert each frame to a data URL
                    recordingFrames.forEach((frame, index) => {
                        try {
                            // Clear temp canvas
                            tempCtx.fillStyle = "#000";
                            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                            
                            // Draw frame centered and scaled
                            tempCtx.drawImage(frame, 0, 0, frame.width, frame.height, 
                                             0, 0, tempCanvas.width, tempCanvas.height);
                            
                            // Get data URL
                            const dataUrl = tempCanvas.toDataURL('image/jpeg', 0.7); // Using JPEG for smaller size
                            frameDataUrls.push(dataUrl);
                            
                            // Update progress
                            recordVideoButton.textContent = `Creating animation ${Math.round((index+1) / recordingFrames.length * 100)}%`;
                        } catch (e) {
                            debugLog(`Error processing frame ${index}: ${e.message}`, true);
                        }
                    });
                    
                    debugLog(`Created ${frameDataUrls.length} frame data URLs`);
                    
                    // Create a video download option
                    debugLog("Creating downloadable video file");
                    recordVideoButton.textContent = "Creating video...";

                    // Create a canvas for video recording
                    const videoCanvas = document.createElement('canvas');
                    videoCanvas.width = frameSize;
                    videoCanvas.height = frameSize;
                    const videoCtx = videoCanvas.getContext('2d');

                    // Create a media stream from the canvas
                    const stream = videoCanvas.captureStream(30); // 30fps

                    // Check which MIME types are supported
                    function getSupportedMimeType() {
                        const types = [
                            'video/webm;codecs=vp9',
                            'video/webm;codecs=vp8',
                            'video/webm',
                            'video/mp4',
                            'video/mpeg'
                        ];
                        
                        for (let type of types) {
                            if (MediaRecorder.isTypeSupported(type)) {
                                debugLog(`Using supported MIME type: ${type}`);
                                return type;
                            }
                        }
                        
                        debugLog('No supported video MIME types found', true);
                        return '';
                    }

                    // Get supported MIME type
                    const mimeType = getSupportedMimeType();

                    // Create MediaRecorder with supported type
                    let mediaRecorder;
                    try {
                        const options = {};
                        if (mimeType) {
                            options.mimeType = mimeType;
                            options.videoBitsPerSecond = 2500000; // 2.5 Mbps
                        }
                        
                        mediaRecorder = new MediaRecorder(stream, options);
                        debugLog(`MediaRecorder created with options: ${JSON.stringify(options)}`);
                    } catch (err) {
                        debugLog(`MediaRecorder error: ${err.message}`, true);
                        // Continue with just the animation, without video recording
                        throw new Error(`Video recording not supported: ${err.message}`);
                    }

                    // Store video chunks
                    const chunks = [];
                    mediaRecorder.ondataavailable = e => {
                        if (e.data.size > 0) {
                            chunks.push(e.data);
                        }
                    };

                    // Create download buttons
                    const downloadGridBtn = document.createElement('a');
                    downloadGridBtn.className = 'btn btn-sm btn-outline-primary';
                    downloadGridBtn.textContent = 'Download Grid';
                    downloadGridBtn.href = staticImageUrl;
                    downloadGridBtn.download = `pixel-cube-frames-${snapshotCount}.png`;

                    const downloadVideoBtn = document.createElement('a');
                    downloadVideoBtn.className = 'btn btn-sm btn-outline-primary disabled';
                    downloadVideoBtn.textContent = 'Preparing Video...';
                    
                    // Set file extension based on MIME type
                    const fileExtension = mimeType.includes('mp4') ? 'mp4' : 'webm';
                    downloadVideoBtn.download = `pixel-cube-video-${snapshotCount}.${fileExtension}`;

                    // Handle video completion
                    mediaRecorder.onstop = () => {
                        // Create blob from chunks
                        const videoBlob = new Blob(chunks, { type: 'video/webm' });
                        const videoUrl = URL.createObjectURL(videoBlob);
                        debugLog(`Video created: ${Math.round(videoBlob.size/1024)}KB`);
                        
                        // Update the download button to enable video download
                        downloadVideoBtn.href = videoUrl;
                        downloadVideoBtn.classList.remove('disabled');
                        downloadVideoBtn.textContent = 'Download Video';
                    };

                    // Start recording
                    mediaRecorder.start();

                    // Create each frame for the video
                    let frameIndex = 0;
                    function processNextVideoFrame() {
                        if (frameIndex >= frameDataUrls.length) {
                            // All frames processed, finish video
                            mediaRecorder.stop();
                            return;
                        }
                        
                        // Create an image from the current frame
                        const img = new Image();
                        img.onload = () => {
                            // Draw the frame to the video canvas
                            videoCtx.fillStyle = "#000";
                            videoCtx.fillRect(0, 0, videoCanvas.width, videoCanvas.height);
                            videoCtx.drawImage(img, 0, 0, videoCanvas.width, videoCanvas.height);
                            
                            // Update progress
                            recordVideoButton.textContent = `Creating video ${Math.round((frameIndex+1) / frameDataUrls.length * 100)}%`;
                            
                            // Wait for next frame (matching our original 5fps)
                            setTimeout(() => {
                                frameIndex++;
                                processNextVideoFrame();
                            }, 200); // 200ms = 5fps
                        };
                        
                        img.onerror = () => {
                            debugLog(`Error loading frame ${frameIndex} for video`, true);
                            frameIndex++;
                            processNextVideoFrame();
                        };
                        
                        img.src = frameDataUrls[frameIndex];
                    }

                    // Start processing frames
                    processNextVideoFrame();

                    // Create the controls differently
                    const controlsDiv = document.createElement('div');
                    controlsDiv.className = 'animation-controls d-flex mt-2 justify-content-between';

                    // Create animation control buttons div
                    const animBtnsDiv = document.createElement('div');
                    animBtnsDiv.className = 'd-flex';

                    // Play/pause button
                    const playPauseBtn = document.createElement('button');
                    playPauseBtn.className = 'btn btn-sm btn-outline-primary me-2';
                    playPauseBtn.textContent = 'Play';

                    // Reset button
                    const resetBtn = document.createElement('button');
                    resetBtn.className = 'btn btn-sm btn-outline-secondary';
                    resetBtn.textContent = 'Reset';

                    // Add buttons to their containers
                    animBtnsDiv.appendChild(playPauseBtn);
                    animBtnsDiv.appendChild(resetBtn);

                    // Downloads div
                    const downloadsDiv = document.createElement('div');
                    downloadsDiv.className = 'd-flex';
                    downloadsDiv.appendChild(downloadGridBtn);
                    downloadsDiv.appendChild(document.createTextNode(' '));
                    downloadsDiv.appendChild(downloadVideoBtn);

                    // Add both groups to controls div
                    controlsDiv.appendChild(animBtnsDiv);
                    controlsDiv.appendChild(downloadsDiv);

                    // Then update the card footer to remove the download button (since it's now in the controls)
                    // Create card footer
                    const cardFooter = document.createElement('div');
                    cardFooter.className = 'card-footer text-center';
                    cardFooter.innerHTML = `
                        <div class="d-flex justify-content-between align-items-center">
                            <small class="text-muted">Frames: ${frameDataUrls.length}</small>
                            <small class="text-success">5 fps animation</small>
                        </div>
                    `;

                    // Create an element to show in gallery
                    const videoEl = document.createElement('div');
                    videoEl.className = 'col-12 col-md-6';
                    snapshotCount++;
                    
                    // Create container div for card
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'card';
                    
                    // Create card body for animation
                    const cardBody = document.createElement('div');
                    cardBody.className = 'card-body p-2 text-center';

                    // Create a container for the animation
                    const animContainer = document.createElement('div');
                    animContainer.className = 'animation-container';
                    animContainer.style.position = 'relative';
                    animContainer.style.width = `${frameSize}px`;
                    animContainer.style.height = `${frameSize}px`;
                    animContainer.style.overflow = 'hidden';
                    animContainer.style.backgroundColor = '#000';
                    animContainer.style.margin = '0 auto'; // Center it horizontally

                    // Create image element to animate
                    const animImage = document.createElement('img');
                    animImage.style.width = '100%';
                    animImage.style.height = '100%';
                    animImage.src = frameDataUrls[0]; // Set first frame as initial image
                    animContainer.appendChild(animImage);

                    // Add it to cardBody before the controls
                    cardBody.appendChild(animContainer);
                    cardBody.appendChild(controlsDiv);

                    // Animation state and functions
                    let isPlaying = false;
                    let currentFrame = 0;
                    let animationInterval;

                    // Animation function
                    function updateAnimation() {
                        currentFrame = (currentFrame + 1) % frameDataUrls.length;
                        animImage.src = frameDataUrls[currentFrame];
                    }

                    // Play/pause function
                    function togglePlayPause() {
                        if (isPlaying) {
                            clearInterval(animationInterval);
                            playPauseBtn.textContent = 'Play';
                        } else {
                            animationInterval = setInterval(updateAnimation, 200); // 5fps
                            playPauseBtn.textContent = 'Pause';
                        }
                        isPlaying = !isPlaying;
                    }

                    // Reset function
                    function resetAnimation() {
                        if (isPlaying) {
                            clearInterval(animationInterval);
                            isPlaying = false;
                            playPauseBtn.textContent = 'Play';
                        }
                        currentFrame = 0;
                        animImage.src = frameDataUrls[0];
                    }

                    // Attach event handlers
                    playPauseBtn.addEventListener('click', togglePlayPause);
                    resetBtn.addEventListener('click', resetAnimation);

                    // Assemble elements
                    cardDiv.appendChild(cardBody);
                    cardDiv.appendChild(cardFooter);
                    videoEl.appendChild(cardDiv);
                    
                    // Add to gallery
                    debugLog("Adding web animation to snapshots container");
                    snapshotsDiv.prepend(videoEl);
                    snapshotsContainer.style.display = 'block';
                    
                } catch (error) {
                    debugLog("Error processing frames: " + error.message, true);
                    alert("Error creating animation: " + error.message);
                } finally {
                    // Always clean up and reset state
                    isRecording = false;
                    recordingFrames = [];
                    recordVideoButton.textContent = "Capture Video"; // Changed from "Capture Frames"
                    recordVideoButton.disabled = false;
                }
            }

            // Add event listeners
            window.addEventListener('resize', handleResize);
            
            // Show controls immediately 
            setTimeout(() => {
                console.log('Showing controls...');
                handleResize();
                startPrompt.style.display = 'none'; // Hide the start prompt
                controls.style.display = 'block'; // Show controls with camera button
                
                // Start animation loop immediately, so we can at least show a message
                animate();
            }, 500);
            
            // Keep the manual button for non-Mac or if auto-start fails
            startButton.addEventListener('click', () => {
                console.log('Starting webcam initialization...');
                handleResize();
                initWebcam().catch(err => {
                    console.error('Failed to initialize webcam:', err);
                });
            });
            
            switchCameraButton.addEventListener('click', switchCamera);
            takeSnapshotButton.addEventListener('click', takeSnapshot);
            recordVideoButton.addEventListener('click', startRecording);

            // Add this code inside the DOMContentLoaded event listener
            // to override console.log for debug panel integration
            const originalConsoleLog = console.log;
            const originalConsoleError = console.error;

            console.log = function() {
                // Call the original console.log without triggering debugLog
                originalConsoleLog.apply(console, arguments);
                
                // Only log to debug panel if this isn't coming from debugLog itself
                const stack = new Error().stack || '';
                if (!stack.includes('debugLog')) {
                    const message = Array.from(arguments).join(' ');
                    debugLog(message);
                }
            };

            console.error = function() {
                // Call the original console.error
                originalConsoleError.apply(console, arguments);
                
                // Only log to debug panel if this isn't coming from debugLog itself
                const stack = new Error().stack || '';
                if (!stack.includes('debugLog')) {
                    const message = Array.from(arguments).join(' ');
                    debugLog(message, true);
                }
            };

            debugLog("Console logging overridden for debug panel integration");

            // Add the SimpleGif object implementation inside the DOMContentLoaded event listener
            // Add this right after the debugLog function definition

            // Implement the SimpleGif utility
            window.SimpleGif = {
                createFromFrames: function(frames, options = {}) {
                    return new Promise((resolve, reject) => {
                        // Define variables at the top level
                        let gridPreviewUrl = null;
                        let gridWidth = options.width || 640;
                        let gridHeight = options.height || 480;
                        let frameCount = frames ? frames.length : 0;
                        let gifError = null;
                        
                        try {
                            if (!frames || frames.length === 0) {
                                throw new Error("No frames provided for GIF creation");
                            }
                            
                            debugLog("Creating animated GIF from " + frames.length + " frames");
                            
                            // Create static preview first
                            let gridCanvas = document.createElement('canvas');
                            gridCanvas.width = gridWidth;
                            gridCanvas.height = gridHeight;
                            let gridCtx = gridCanvas.getContext('2d');
                            
                            // Fill with black background
                            gridCtx.fillStyle = "#000";
                            gridCtx.fillRect(0, 0, gridWidth, gridHeight);
                            
                            // Draw frames in a grid
                            const gridSize = Math.ceil(Math.sqrt(frames.length));
                            const cellWidth = Math.floor(gridWidth / gridSize);
                            const cellHeight = Math.floor(gridHeight / gridSize);
                            
                            // Draw each frame in the grid
                            frames.forEach((frame, i) => {
                                try {
                                    const row = Math.floor(i / gridSize);
                                    const col = i % gridSize;
                                    const x = col * cellWidth;
                                    const y = row * cellHeight;
                                    
                                    // Draw the frame
                                    gridCtx.drawImage(frame, 0, 0, frame.width, frame.height, x, y, cellWidth, cellHeight);
                                    
                                    // Draw frame number
                                    gridCtx.fillStyle = "rgba(255, 255, 255, 0.7)";
                                    gridCtx.font = "14px Arial";
                                    gridCtx.fillText((i+1).toString(), x + 5, y + 20);
                                } catch (frameError) {
                                    debugLog(`Error drawing frame ${i} in grid: ${frameError.message}`, true);
                                }
                            });
                            
                            // Get preview URL
                            try {
                                gridPreviewUrl = gridCanvas.toDataURL('image/png');
                                debugLog("Created grid preview successfully");
                            } catch (previewError) {
                                debugLog("Error creating grid preview: " + previewError.message, true);
                            }
                            
                            // Now try to create an animated GIF with a more direct approach
                            debugLog("Starting direct GIF creation");
                            
                            // Prepare frames for GIF
                            const gifFramesPromises = frames.map((frame, index) => {
                                return new Promise((resolveFrame) => {
                                    try {
                                        // Create a new canvas for this frame
                                        const frameCanvas = document.createElement('canvas');
                                        const frameSize = 200; // Reduced size for better performance
                                        frameCanvas.width = frameSize;
                                        frameCanvas.height = frameSize;
                                        const frameCtx = frameCanvas.getContext('2d');
                                        
                                        // Draw black background
                                        frameCtx.fillStyle = '#000000';
                                        frameCtx.fillRect(0, 0, frameSize, frameSize);
                                        
                                        // Draw the frame content, scaled down
                                        frameCtx.drawImage(frame, 0, 0, frame.width, frame.height, 
                                                          0, 0, frameSize, frameSize);
                                        
                                        // Convert to data URL
                                        frameCanvas.toBlob((blob) => {
                                            resolveFrame({
                                                blob: blob,
                                                url: URL.createObjectURL(blob),
                                                index: index
                                            });
                                        }, 'image/png');
                                    } catch (err) {
                                        debugLog(`Error preparing frame ${index}: ${err.message}`, true);
                                        // Return a placeholder if frame preparation fails
                                        resolveFrame({
                                            error: err.message,
                                            index: index
                                        });
                                    }
                                });
                            });
                            
                            // Wait for all frames to be prepared
                            Promise.all(gifFramesPromises)
                            .then(preparedFrames => {
                                debugLog(`All ${preparedFrames.length} frames prepared for GIF`);
                                
                                // Try creating a GIF with gif.js
                                try {
                                    if (typeof GIF === 'undefined') {
                                        throw new Error("GIF.js library not available");
                                    }
                                    
                                    // Create a new GIF
                                    const frameSize = 200; // Match the size used in frame preparation
                                    const gif = new GIF({
                                        workers: 2,
                                        quality: 10,
                                        width: frameSize,
                                        height: frameSize,
                                        workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js'
                                    });
                                    
                                    // Add each prepared frame
                                    preparedFrames.forEach((frameData, index) => {
                                        if (!frameData.error && frameData.blob) {
                                            const img = new Image();
                                            img.src = frameData.url;
                                            
                                            // Need to wait for the image to load
                                            img.onload = function() {
                                                gif.addFrame(img, {delay: 200}); // 200ms = 5fps
                                                
                                                // If this is the last frame, render the GIF
                                                if (index === preparedFrames.length - 1) {
                                                    debugLog("All frames added to GIF, rendering...");
                                                    gif.render();
                                                }
                                            };
                                            
                                            img.onerror = function() {
                                                debugLog(`Error loading image for frame ${index}`, true);
                                                // If this is the last frame, render anyway
                                                if (index === preparedFrames.length - 1) {
                                                    gif.render();
                                                }
                                            };
                                        }
                                    });
                                    
                                    // Handle GIF completion
                                    gif.on('finished', function(blob) {
                                        debugLog(`GIF created successfully! Size: ${Math.round(blob.size/1024)}KB`);
                                        
                                        // Create a URL for the GIF
                                        const gifUrl = URL.createObjectURL(blob);
                                        
                                        // Success! Return the GIF URL
                                        resolve({
                                            url: gifUrl,
                                            blob: blob,
                                            width: frameSize,
                                            height: frameSize,
                                            frameCount: frames.length,
                                            isAnimated: true
                                        });
                                    });
                                    
                                    // Handle GIF progress
                                    gif.on('progress', function(p) {
                                        debugLog(`GIF encoding: ${Math.round(p*100)}%`);
                                    });
                                    
                                } catch (gifErr) {
                                    gifError = gifErr;
                                    throw gifErr;
                                }
                            })
                            .catch(err => {
                                debugLog("Error in GIF creation: " + err.message, true);
                                
                                // Fall back to the static preview
                                resolve({
                                    url: gridPreviewUrl || "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==",
                                    width: gridWidth,
                                    height: gridHeight,
                                    frameCount: frameCount,
                                    isAnimated: false,
                                    error: err.message
                                });
                            });
                            
                        } catch (error) {
                            debugLog("Critical error in GIF creation: " + error.message, true);
                            
                            // Create a fallback preview if needed
                            if (!gridPreviewUrl) {
                                try {
                                    const fallbackCanvas = document.createElement('canvas');
                                    fallbackCanvas.width = gridWidth;
                                    fallbackCanvas.height = gridHeight;
                                    const fallbackCtx = fallbackCanvas.getContext('2d');
                                    fallbackCtx.fillStyle = "#333";
                                    fallbackCtx.fillRect(0, 0, fallbackCanvas.width, fallbackCanvas.height);
                                    fallbackCtx.fillStyle = "#FFF";
                                    fallbackCtx.font = "20px Arial";
                                    fallbackCtx.fillText("GIF Creation Failed", gridWidth/2 - 100, gridHeight/2);
                                    fallbackCtx.font = "16px Arial";
                                    fallbackCtx.fillText(error.message, gridWidth/2 - 150, gridHeight/2 + 30);
                                    gridPreviewUrl = fallbackCanvas.toDataURL('image/png');
                                } catch (e) {
                                    gridPreviewUrl = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
                                }
                            }
                            
                            // Fall back to the static preview
                            resolve({
                                url: gridPreviewUrl,
                                width: gridWidth,
                                height: gridHeight,
                                frameCount: frameCount,
                                isAnimated: false,
                                error: error.message
                            });
                        }
                    });
                }
            };

            // Update the version tag code to include a fixed version number
            const buildDate = new Date().toLocaleDateString();
            const versionNumber = "v0.3b"; // Incrementing version number
            document.getElementById('versionInfo').textContent = `${versionNumber} (${buildDate})`;
            debugLog(`Version info set: ${versionNumber} built on ${buildDate}`);
        });
    </script>
</body>
</html>
